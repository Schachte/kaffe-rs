"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  polyfillNode: () => polyfillNode,
  polyfillNodeForDeno: () => polyfillNodeForDeno
});
module.exports = __toCommonJS(src_exports);
var import_node_url = require("url");
var import_node_path = require("path");
var import_meta = {};
var filename = typeof __filename === "undefined" ? (0, import_node_url.fileURLToPath)(import_meta.url) : __filename;
var importMetaUrl = import_meta.url ?? (0, import_node_url.pathToFileURL)(filename).href;
function polyfillNode(options = {}) {
  const { globals = {}, polyfills = {} } = options;
  const {
    global = true,
    __dirname = true,
    __filename: __filename2 = true,
    buffer = true,
    process = true,
    navigator = false
  } = globals || {
    global: false,
    __dirname: false,
    __filename: false,
    buffer: false,
    process: false,
    navigator: false
  };
  polyfills.fs = polyfills.fs ?? "empty";
  polyfills.crypto = polyfills.crypto ?? "empty";
  polyfills.dns = polyfills.dns ?? "empty";
  polyfills.dgram = polyfills.dgram ?? "empty";
  polyfills.cluster = polyfills.cluster ?? "empty";
  polyfills.repl = polyfills.repl ?? "empty";
  polyfills.tls = polyfills.tls ?? "empty";
  const moduleNames = [...jspmPolyiflls];
  const filter = new RegExp(`^(node:)?(${moduleNames.join("|")})$`);
  return {
    name: "node-polyfills",
    async setup(build) {
      const fsResolved = await resolveImport(`@jspm/core/nodelibs/fs`);
      build.onResolve({ filter }, async ({ path }) => {
        const [, , moduleName] = path.match(filter);
        const polyfill = polyfills[moduleName] ?? true;
        if (polyfill === false) {
          return;
        } else if (polyfill === "empty") {
          return { path: (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/empty.js") };
        } else if (!jspmPolyiflls.has(moduleName)) {
          throw new Error("Cannot find polyfill for " + moduleName);
        }
        const resolved = (0, import_node_path.resolve)(fsResolved, `../../browser/${moduleName}.js`);
        return { path: resolved };
      });
      if (globals) {
        build.initialOptions.inject = build.initialOptions.inject || [];
        if (global) {
          (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/global.js");
        }
        if (__dirname) {
          build.initialOptions.inject.push(
            (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/__dirname.js")
          );
        }
        if (__filename2) {
          (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/__filename.js");
        }
        if (buffer) {
          build.initialOptions.inject.push(
            (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/buffer.js")
          );
        }
        if (process) {
          build.initialOptions.inject.push(
            (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/process.js")
          );
        }
        if (navigator) {
          build.initialOptions.inject.push(
            (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/navigator.js")
          );
        }
      }
    }
  };
}
function polyfillNodeForDeno(options = {}) {
  const { stdVersion = "0.177.0", globals = true, polyfills = {} } = options;
  const moduleNames = [.../* @__PURE__ */ new Set([...denoPolyfills])];
  const filter = new RegExp(`^(node:)?(${moduleNames.join("|")})$`);
  return {
    name: "node-polyfills",
    setup(build) {
      build.onResolve(
        {
          filter: /^virtual:deno-std-node-global$/
        },
        () => ({
          path: `https://deno.land/std@${stdVersion}/node/global.ts`,
          external: true
        })
      );
      build.onResolve({ filter }, async ({ path }) => {
        const [, , moduleName] = path.match(filter);
        const polyfill = polyfills[moduleName] ?? true;
        if (polyfill === false) {
          return;
        } else if (polyfill === "empty") {
          return {
            path: (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/empty.js")
          };
        } else {
          if (!denoPolyfills.has(moduleName)) {
            throw new Error("Cannot find the Deno polyfill for " + moduleName);
          }
          return {
            path: `https://deno.land/std@${stdVersion}/node/${moduleName}.ts`,
            external: true
          };
        }
      });
      build.onLoad({ namespace: "polyfillNodeForDeno", filter: /.*/ }, () => ({
        contents: denoGlobalsContents(stdVersion)
      }));
      if (globals) {
        build.initialOptions.footer;
        build.initialOptions.inject = build.initialOptions.inject || [];
        build.initialOptions.inject.push(
          (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/global-for-deno.js"),
          (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/__dirname.js"),
          (0, import_node_path.resolve)((0, import_node_path.dirname)(filename), "../polyfills/__filename.js")
        );
      }
    }
  };
}
var jspmPolyiflls = /* @__PURE__ */ new Set([
  "_stream_duplex",
  "_stream_passthrough",
  "_stream_readable",
  "_stream_transform",
  "_stream_writable",
  "assert",
  "assert/strict",
  "async_hooks",
  "buffer",
  "child_process",
  "cluster",
  "console",
  "constants",
  "crypto",
  "dgram",
  "diagnostics_channel",
  "dns",
  "domain",
  "events",
  "fs",
  "fs/promises",
  "http",
  "http2",
  "https",
  "module",
  "net",
  "os",
  "path",
  "perf_hooks",
  "process",
  "punycode",
  "querystring",
  "readline",
  "repl",
  "stream",
  "string_decoder",
  "sys",
  "timers",
  "timers/promises",
  "tls",
  "tty",
  "url",
  "util",
  "v8",
  "vm",
  "wasi",
  "worker_threads",
  "zlib"
]);
var denoPolyfills = /* @__PURE__ */ new Set([
  "assert",
  "assert/strict",
  "buffer",
  "console",
  "constants",
  "crypto",
  "child_process",
  "dns",
  "events",
  "fs",
  "fs/promises",
  "http",
  "module",
  "net",
  "os",
  "path",
  "perf_hooks",
  "process",
  "querystring",
  "readline",
  "stream",
  "string_decoder",
  "sys",
  "timers",
  "timers/promises",
  "tty",
  "url",
  "util",
  "worker_threads"
]);
var importMetaResolve;
async function resolveImport(specifier) {
  if (!importMetaResolve) {
    importMetaResolve = (await import("import-meta-resolve")).resolve;
  }
  const resolved = await importMetaResolve(specifier, importMetaUrl);
  return (0, import_node_url.fileURLToPath)(resolved);
}
function denoGlobalsContents(stdVersion) {
  return `
		import "https://deno.land/std@${stdVersion}/node/global.ts";
		export const process = globalThis.process;
		export const Buffer = globalThis.Buffer;
		export const setImmediate = globalThis.setImmediate;
		export const clearImmediate = globalThis.clearImmediate;
	`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  polyfillNode,
  polyfillNodeForDeno
});
